name: Test Steps

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      platform:
        required: true
        type: string
        description: "Platform (macos/windows)"
      venv_path:
        required: true
        type: string
        description: "Path to virtual environment"
      use_cache:
        required: false
        type: boolean
        default: false
        description: "Whether to use caching for packages"
      install_deps:
        required: false
        type: boolean
        default: false
        description: "Whether to install minimal dependencies"
      setup_python:
        required: false
        type: boolean
        default: false
        description: "Whether to use the setup file for virtual environment"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.job }}-${{ github.run_id }}
  cancel-in-progress: true

jobs:
  run-tests:
    runs-on: ${{ inputs.platform }}-latest
    steps:
      - name: Debug environment
        shell: bash
        run: |
          echo "=== Environment Debug Info ==="
          echo "Platform: ${{ inputs.platform }}"
          echo "venv_path: ${{ inputs.venv_path }}"
          echo "use_cache: ${{ inputs.use_cache }}"
          echo "install_deps: ${{ inputs.install_deps }}"
          echo "setup_python: ${{ inputs.setup_python }}"
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          echo "==========================="

      - name: Debug Windows environment
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Windows Environment Debug Info ==="
          Write-Output "Current directory: $(Get-Location)"
          Write-Output "Directory contents:"
          Get-ChildItem
          Write-Output "Environment variables:"
          Get-ChildItem env: | Format-Table -AutoSize
          Write-Output "PATH: $env:Path"
          Write-Output "Python version: $(python --version)"
          Write-Output "================================"

      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Log Python venv cache info (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            Write-Output "=== Python venv Cache Info ==="
            $cachePath = "${{ runner.tool_cache }}/venv"
            Write-Output "Cache path: $cachePath"
            Write-Output "Cache key: ${{ runner.os }}-${{ runner.arch }}-venv-${{ hashFiles('infra/packages/pip.sh', 'infra/packages/pip.ps1') }}"

            if (Test-Path $cachePath) {
              $size = (Get-ChildItem -Path $cachePath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
              Write-Output "Cache size: $size MB"
            } else {
              Write-Output "Cache size: Not found"
            }
            Write-Output "==========================="
          } catch {
            $errorDetails = @{
              Message = $_.Exception.Message
              ScriptStackTrace = $_.ScriptStackTrace
              Time = Get-Date
              Environment = @{
                Path = $env:Path
                CurrentDirectory = Get-Location
              }
            }
            Write-Output ($errorDetails | ConvertTo-Json)
            exit 1
          }

      - name: Validate cache (Windows)
        if: inputs.platform == 'windows' && steps.python-venv-cache.outputs.cache-hit == 'true'
        shell: pwsh
        run: |
          try {
            $venvPath = "${{ runner.tool_cache }}/venv"
            $pythonExe = Join-Path $venvPath "Scripts\python.exe"
            $activateScript = Join-Path $venvPath "Scripts\Activate.ps1"

            if (-not (Test-Path $pythonExe)) {
              Write-Error "Cache is invalid: Python executable not found"
              exit 1
            }

            if (-not (Test-Path $activateScript)) {
              Write-Error "Cache is invalid: Activation script not found"
              exit 1
            }

            # Test activation
            . $activateScript
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Cache is invalid: Activation failed"
              exit 1
            }

            Write-Output "Cache validation successful"
          } catch {
            $errorDetails = @{
              Message = $_.Exception.Message
              ScriptStackTrace = $_.ScriptStackTrace
              Time = Get-Date
              Environment = @{
                Path = $env:Path
                CurrentDirectory = Get-Location
              }
            }
            Write-Output ($errorDetails | ConvertTo-Json)
            exit 1
          }

      - name: Log Python venv cache info (macOS)
        if: inputs.platform == 'macos'
        shell: bash
        run: |
          echo "=== Python venv Cache Info ==="
          echo "Cache path: ${{ runner.tool_cache }}/venv"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-venv-${{ hashFiles('infra/packages/pip.sh', 'infra/packages/pip.ps1') }}"
          echo "Cache size: $(du -sh ${{ runner.tool_cache }}/venv 2>/dev/null || echo 'Not found')"
          echo "==========================="

      - name: Restore Python venv from cache
        uses: actions/cache@v4
        id: python-venv-cache
        with:
          path: ${{ runner.tool_cache }}/venv
          key: ${{ runner.os }}-${{ runner.arch }}-venv-${{ hashFiles('infra/packages/pip.sh', 'infra/packages/pip.ps1') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-venv-

      - name: Log Python venv cache result (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Python venv Cache Result ==="
          Write-Output "Cache hit: ${{ steps.python-venv-cache.outputs.cache-hit }}"
          Write-Output "Cache size after restore: $((Get-ChildItem -Path $env:RUNNER_TOOL_CACHE/venv -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB)"
          Write-Output "=============================="

      - name: Log Python venv cache result (macOS)
        if: inputs.platform == 'macos'
        shell: bash
        run: |
          echo "=== Python venv Cache Result ==="
          echo "Cache hit: ${{ steps.python-venv-cache.outputs.cache-hit }}"
          echo "Cache size after restore: $(du -sh ${{ runner.tool_cache }}/venv 2>/dev/null || echo 'Not found')"
          echo "=============================="

      - name: Log Virtual Environment Installation
        if: inputs.install_deps
        shell: pwsh
        run: |
          Write-Output "=== Virtual Environment Installation Debug ==="
          Write-Output "venv_path: ${{ inputs.venv_path }}"
          Write-Output "Current directory: $(Get-Location)"
          Write-Output "Directory contents:"
          Get-ChildItem

          # Check if virtual environment exists
          if (Test-Path ${{ inputs.venv_path }}) {
              Write-Output "Virtual environment exists at: ${{ inputs.venv_path }}"
              Write-Output "Virtual environment contents:"
              Get-ChildItem ${{ inputs.venv_path }} -Recurse
          } else {
              Write-Output "Virtual environment not found at: ${{ inputs.venv_path }}"
          }

          # Check Python version and path
          Write-Output "Python version: $(python --version)"
          Write-Output "Python path: $(Get-Command python | Select-Object -ExpandProperty Source)"
          Write-Output "PATH: $env:Path"
          Write-Output "================================"

      - name: Install minimal dependencies (Windows)
        if: inputs.install_deps && inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            $ErrorActionPreference = 'Stop'
            $env:PYTHONIOENCODING = 'utf-8'  # Ensure proper encoding

            # Get the virtual environment path
            $venvPath = "${{ inputs.venv_path }}"
            Write-Output "Using virtual environment at: $venvPath"

            # Normalize the path for Windows
            $venvPath = [System.IO.Path]::GetFullPath($venvPath)
            Write-Output "Normalized path: $venvPath"

            # Create parent directory if it doesn't exist
            $parentDir = Split-Path -Parent $venvPath
            if (-not (Test-Path $parentDir)) {
                Write-Output "Creating parent directory: $parentDir"
                New-Item -ItemType Directory -Path $parentDir -Force | Out-Null
            }

            # Verify virtual environment exists
            if (-not (Test-Path $venvPath)) {
                Write-Error "Virtual environment not found at: $venvPath"
                Write-Output "Current directory: $(Get-Location)"
                Write-Output "Directory contents:"
                Get-ChildItem | Format-Table -AutoSize
                Write-Output "Parent directory contents:"
                Get-ChildItem $parentDir | Format-Table -AutoSize
                exit 1
            }

            # Verify activation script exists
            $activateScript = Join-Path $venvPath "Scripts\Activate.ps1"
            Write-Output "Checking activation script at: $activateScript"

            if (-not (Test-Path $activateScript)) {
                Write-Error "Activation script not found at: $activateScript"
                Write-Output "Virtual environment contents:"
                Get-ChildItem $venvPath -Recurse | Format-Table -AutoSize
                exit 1
            }

            # Check for Zone.Identifier and unblock if needed
            if (Get-Item $activateScript -Stream Zone.Identifier -ErrorAction SilentlyContinue) {
                Write-Output "Zone.Identifier found! Unblocking script..."
                Unblock-File -Path $activateScript
            }

            # Set execution policy for the process
            $currentPolicy = Get-ExecutionPolicy
            Write-Output "Current execution policy: $currentPolicy"
            Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
            Write-Output "Set execution policy to Bypass for this process"

            # Activate virtual environment
            Write-Output "Activating virtual environment..."
            Write-Output "Current PATH before activation: $env:Path"
            Write-Output "Current Python before activation: $(Get-Command python | Select-Object -ExpandProperty Source)"

            # Debug virtual environment structure
            Write-Output "=== Virtual Environment Structure ==="
            Get-ChildItem $venvPath -Recurse | Where-Object { $_.Name -like "*.exe" -or $_.Name -like "*.ps1" } | Format-Table -AutoSize
            Write-Output "==================================="

            # Source the activation script with error handling and timeout
            $job = Start-Job -ScriptBlock {
                param($scriptPath, $venvPath)
                try {
                    Write-Output "Activation script path: $scriptPath"
                    Write-Output "Virtual environment path: $venvPath"

                    # Check if activation script exists
                    if (-not (Test-Path $scriptPath)) {
                        throw "Activation script not found at: $scriptPath"
                    }

                    # Check script content and permissions
                    Write-Output "Activation script content:"
                    Get-Content $scriptPath
                    Write-Output "Script permissions:"
                    Get-Acl $scriptPath | Format-List

                    # Set execution policy for this process
                    Write-Output "Current execution policy: $(Get-ExecutionPolicy)"
                    Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
                    Write-Output "New execution policy: $(Get-ExecutionPolicy)"

                    # Ensure proper environment setup
                    $env:PYTHONIOENCODING = 'utf-8'
                    $env:PYTHONUNBUFFERED = '1'
                    $env:VIRTUAL_ENV = $venvPath

                    # Try activation with detailed error capture
                    $ErrorActionPreference = 'Continue'
                    Write-Output "Attempting to activate virtual environment..."

                    # Use dot-sourcing instead of direct execution
                    . $scriptPath
                    $exitCode = $LASTEXITCODE
                    Write-Output "Activation completed with exit code: $exitCode"

                    # Verify activation by checking environment variables
                    Write-Output "Checking environment after activation..."
                    Write-Output "VIRTUAL_ENV: $env:VIRTUAL_ENV"
                    Write-Output "PATH: $env:Path"

                    if ($exitCode -ne 0) {
                        throw "Activation script failed with exit code $exitCode"
                    }

                    # Verify Python path after activation
                    $pythonPath = (Get-Command python | Select-Object -ExpandProperty Source)
                    Write-Output "Python path after activation: $pythonPath"
                    Write-Output "Expected to start with: $venvPath"

                    if (-not $pythonPath.StartsWith($venvPath)) {
                        throw "Python path does not point to virtual environment"
                    }

                    # Verify environment variables
                    Write-Output "Environment variables after activation:"
                    Get-ChildItem env: | Where-Object { $_.Name -like "*PYTHON*" -or $_.Name -like "*VIRTUAL*" } | Format-Table -AutoSize

                    Write-Output "Activation successful"
                } catch {
                    Write-Error $_.Exception.Message
                    Write-Output "Error details: $_"
                    Write-Output "Script stack trace: $($_.ScriptStackTrace)"
                    Write-Output "Current location: $(Get-Location)"
                    Write-Output "Environment variables:"
                    Get-ChildItem env: | Format-Table -AutoSize
                    Write-Output "Python version: $(python --version 2>&1)"
                    Write-Output "Python path: $(Get-Command python -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source)"
                    throw
                }
            } -ArgumentList $activateScript, $venvPath

            $timeout = 30  # 30 seconds timeout
            $result = Wait-Job $job -Timeout $timeout
            if ($result -eq $null) {
                Stop-Job $job
                Remove-Job $job
                throw "Activation script timed out after $timeout seconds"
            }

            $output = Receive-Job $job
            Remove-Job $job

            if ($job.State -eq 'Failed') {
                Write-Error "Activation failed with output:"
                Write-Output $output
                throw "Virtual environment activation failed"
            }

            Write-Output "Activation output:"
            Write-Output $output

            # Verify activation by checking Python path
            $pythonPath = (Get-Command python | Select-Object -ExpandProperty Source)
            if (-not $pythonPath.StartsWith($venvPath)) {
                Write-Error "Python is not using the virtual environment"
                Write-Output "Expected Python path to start with: $venvPath"
                Write-Output "Actual Python path: $pythonPath"
                Write-Output "Current PATH: $env:Path"
                exit 1
            }

            # Install system packages with timeout
            Write-Output "Installing system packages..."
            $chocoJob = Start-Job -ScriptBlock {
                choco install neovim -y
                choco install luarocks -y
            }

            $timeout = 300  # 5 minutes timeout
            $result = Wait-Job $chocoJob -Timeout $timeout
            if ($result -eq $null) {
                Stop-Job $chocoJob
                Remove-Job $chocoJob
                throw "Chocolatey installation timed out after $timeout seconds"
            }

            $output = Receive-Job $chocoJob
            Remove-Job $chocoJob

            if ($chocoJob.State -eq 'Failed') {
                throw "Chocolatey installation failed: $output"
            }

            # Wait for Neovim installation to complete
            Start-Sleep -Seconds 10

            # Verify Neovim installation
            $neovimPath = "C:\tools\neovim\nvim-win64\bin"
            if (-not (Test-Path $neovimPath)) {
                Write-Output "Neovim path not found, checking alternative locations..."
                $neovimPath = Get-ChildItem "C:\tools\neovim" -Recurse -Filter "nvim.exe" -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty DirectoryName
                if (-not $neovimPath) {
                    Write-Error "Neovim installation not found"
                    Write-Output "Checking C:\tools contents:"
                    Get-ChildItem "C:\tools" -Recurse | Format-Table -AutoSize
                    exit 1
                }
            }

            # Add Neovim to PATH
            $env:Path = "$env:Path;$neovimPath"
            Write-Output "Added Neovim to PATH: $neovimPath"

            # Use PowerShell script with Chocolatey and timeout
            Write-Output "Running PowerShell install script..."
            $installJob = Start-Job -ScriptBlock {
                param($scriptPath)
                & $scriptPath -UseChocolatey
            } -ArgumentList "${{ github.workspace }}/infra/install.ps1"

            $timeout = 300  # 5 minutes timeout
            $result = Wait-Job $installJob -Timeout $timeout
            if ($result -eq $null) {
                Stop-Job $installJob
                Remove-Job $installJob
                throw "Install script timed out after $timeout seconds"
            }

            $output = Receive-Job $installJob
            Remove-Job $installJob

            if ($installJob.State -eq 'Failed') {
                throw "Install script failed: $output"
            }
          } catch {
            Write-Error $_.Exception.Message
            Write-Output "Current directory: $(Get-Location)"
            Write-Output "Directory contents:"
            Get-ChildItem | Format-Table -AutoSize
            Write-Output "Environment variables:"
            Get-ChildItem env: | Format-Table -AutoSize
            Write-Output "PATH: $env:Path"
            exit 1
          }

      - name: Verify virtual environment path
        if: inputs.setup_python
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          # Get virtual environment path from setup
          $venvPath = "${{ steps.setup.outputs.virtual_env }}"
          Write-Output "Virtual environment path from setup: $venvPath"

          # Debug path information
          Write-Output "=== Virtual Environment Path Debug ==="
          Write-Output "Raw venv_path: ${{ inputs.venv_path }}"
          Write-Output "Setup output venv_path: $venvPath"
          Write-Output "Current directory: $(Get-Location)"
          Write-Output "Directory contents:"
          Get-ChildItem
          Write-Output "================================"

          # Normalize path for Windows
          if ($IsWindows) {
              $venvPath = [System.IO.Path]::GetFullPath($venvPath)
              Write-Output "Normalized path for Windows: $venvPath"

              # Debug normalized path
              Write-Output "=== Normalized Path Debug ==="
              Write-Output "Full path: $venvPath"
              Write-Output "Parent directory exists: $(Test-Path (Split-Path -Parent $venvPath))"
              Write-Output "Parent directory contents:"
              Get-ChildItem (Split-Path -Parent $venvPath)
              Write-Output "=========================="
          }

          # Verify virtual environment exists
          if (-not (Test-Path $venvPath)) {
              Write-Error "Virtual environment not found at: $venvPath"
              Write-Output "Current directory: $(Get-Location)"
              Write-Output "Directory contents:"
              Get-ChildItem
              exit 1
          }

          # Verify activation script exists
          $activateScript = if ($IsWindows) {
              Join-Path $venvPath "Scripts\Activate.ps1"
          } else {
              Join-Path $venvPath "bin/activate"
          }

          Write-Output "=== Activation Script Debug ==="
          Write-Output "Activation script path: $activateScript"
          Write-Output "Script exists: $(Test-Path $activateScript)"
          if (Test-Path $activateScript) {
              Write-Output "Script contents:"
              Get-Content $activateScript
          }
          Write-Output "============================"

          if (-not (Test-Path $activateScript)) {
              Write-Error "Activation script not found at: $activateScript"
              Write-Output "Virtual environment contents:"
              Get-ChildItem $venvPath -Recurse
              exit 1
          }

          # Activate virtual environment
          Write-Output "=== Activation Debug ==="
          Write-Output "Current PATH: $env:Path"
          Write-Output "Current Python: $(Get-Command python | Select-Object -ExpandProperty Source)"
          Write-Output "========================="

          . $activateScript
          if ($LASTEXITCODE -ne 0) {
              Write-Error "Failed to activate virtual environment"
              Write-Output "Python version: $(python --version)"
              Write-Output "PATH: $env:Path"
              exit 1
          }

          Write-Output "=== Post-Activation Debug ==="
          Write-Output "Updated PATH: $env:Path"
          Write-Output "Updated Python: $(Get-Command python | Select-Object -ExpandProperty Source)"
          Write-Output "============================"

          # Verify Python is using the virtual environment
          $pythonPath = (Get-Command python | Select-Object -ExpandProperty Source)
          if (-not $pythonPath.StartsWith($venvPath)) {
              Write-Error "Python is not using the virtual environment"
              Write-Output "Expected Python path to start with: $venvPath"
              Write-Output "Actual Python path: $pythonPath"
              exit 1
          }

      - name: Log Homebrew cache info
        if: inputs.platform == 'macos' && inputs.use_cache
        shell: bash
        run: |
          echo "=== Homebrew Cache Info ==="
          echo "Cache paths:"
          echo "- ~/Library/Caches/Homebrew"
          echo "- /usr/local/Homebrew"
          echo "- /opt/homebrew"
          echo "- ~/Library/Logs/Homebrew"
          echo "- /opt/homebrew/Library/Caches"
          echo "- /opt/homebrew/Library/Logs"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-homebrew-${{ hashFiles('infra/packages/brew.sh') }}"
          echo "========================="

      - name: Cache Homebrew packages
        if: inputs.platform == 'macos' && inputs.use_cache
        uses: actions/cache@v4
        id: homebrew-cache
        with:
          path: |
            ~/Library/Caches/Homebrew
            /usr/local/Homebrew
            /opt/homebrew
            ~/Library/Logs/Homebrew
            /opt/homebrew/Library/Caches
            /opt/homebrew/Library/Logs
          key: ${{ runner.os }}-${{ runner.arch }}-homebrew-${{ hashFiles('infra/packages/brew.sh') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-homebrew-

      - name: Log Homebrew cache result
        if: inputs.platform == 'macos' && inputs.use_cache
        shell: bash
        run: |
          echo "=== Homebrew Cache Result ==="
          echo "Cache hit: ${{ steps.homebrew-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          du -sh ~/Library/Caches/Homebrew /usr/local/Homebrew /opt/homebrew 2>/dev/null || echo "Not found"
          echo "==========================="

      - name: Log LuaRocks cache info
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== LuaRocks Cache Info ==="
          echo "Cache paths:"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.cache\\luarocks', env.USERPROFILE) || '~/.cache/luarocks' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.luarocks', env.USERPROFILE) || '~/.luarocks' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\luarocks', env.USERPROFILE) || '~/.local/share/luarocks' }}"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-luarocks-${{ hashFiles('infra/packages/luarocks.sh') }}"
          echo "========================="

      - name: Cache LuaRocks packages
        if: inputs.use_cache
        uses: actions/cache@v4
        id: luarocks-cache
        with:
          path: |
            ${{ runner.os == 'Windows' && format('{0}\\.cache\\luarocks', env.USERPROFILE) || '~/.cache/luarocks' }}
            ${{ runner.os == 'Windows' && format('{0}\\.luarocks', env.USERPROFILE) || '~/.luarocks' }}
            ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\luarocks', env.USERPROFILE) || '~/.local/share/luarocks' }}
          key: ${{ runner.os }}-${{ runner.arch }}-luarocks-${{ hashFiles('infra/packages/luarocks.sh') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-luarocks-

      - name: Log LuaRocks cache result
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== LuaRocks Cache Result ==="
          echo "Cache hit: ${{ steps.luarocks-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          if [ "${{ runner.os }}" == "Windows" ]; then
            du -sh "${{ format('{0}\\.cache\\luarocks', env.USERPROFILE) }}" "${{ format('{0}\\.luarocks', env.USERPROFILE) }}" "${{ format('{0}\\.local\\share\\luarocks', env.USERPROFILE) }}" 2>/dev/null || echo "Not found"
          else
            du -sh ~/.cache/luarocks ~/.luarocks ~/.local/share/luarocks 2>/dev/null || echo "Not found"
          fi
          echo "==========================="

      - name: Log Neovim plugins cache info
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== Neovim Plugins Cache Info ==="
          echo "Cache paths:"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\nvim', env.USERPROFILE) || '~/.local/share/nvim' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) || '~/.config/nvim/plugin' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) || '~/.config/nvim/lazy' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\state\\nvim', env.USERPROFILE) || '~/.local/state/nvim' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.cache\\nvim', env.USERPROFILE) || '~/.cache/nvim' }}"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-nvim-plugins-${{ hashFiles('lua/**/*.lua', 'after/plugin/**/*.lua', 'infra/packages/nvim.sh') }}"
          echo "=============================="

      - name: Cache Neovim plugins
        if: inputs.use_cache
        uses: actions/cache@v4
        id: nvim-plugins-cache
        with:
          path: |
            ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\nvim', env.USERPROFILE) || '~/.local/share/nvim' }}
            ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) || '~/.config/nvim/plugin' }}
            ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) || '~/.config/nvim/lazy' }}
            ${{ runner.os == 'Windows' && format('{0}\\.local\\state\\nvim', env.USERPROFILE) || '~/.local/state/nvim' }}
            ${{ runner.os == 'Windows' && format('{0}\\.cache\\nvim', env.USERPROFILE) || '~/.cache/nvim' }}
          key: ${{ runner.os }}-${{ runner.arch }}-nvim-plugins-${{ hashFiles('lua/**/*.lua', 'after/plugin/**/*.lua', 'infra/packages/nvim.sh') }}

      - name: Log Neovim plugins cache result
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== Neovim Plugins Cache Result ==="
          echo "Cache hit: ${{ steps.nvim-plugins-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          if [ "${{ runner.os }}" == "Windows" ]; then
            du -sh "${{ format('{0}\\.local\\share\\nvim', env.USERPROFILE) }}" "${{ format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) }}" "${{ format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) }}" 2>/dev/null || echo "Not found"
          else
            du -sh ~/.local/share/nvim ~/.config/nvim/plugin ~/.config/nvim/lazy 2>/dev/null || echo "Not found"
          fi
          echo "================================"

      - name: Run Lua tests (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            & "${{ inputs.venv_path }}/Scripts/activate.ps1"
            # Ensure Neovim is in PATH and verify it
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
            $env:Path = "$env:Path;C:\tools\neovim\nvim-win64\bin"

            # Verify Neovim is available
            $nvimPath = Get-Command nvim -ErrorAction SilentlyContinue
            if (-not $nvimPath) {
              throw "Neovim not found in PATH before running tests. Current PATH: $env:Path"
            }
            Write-Output "Using Neovim from: $($nvimPath.Source)"

            # Set up Lua environment
            $env:LUA_PATH = "?.lua;?/init.lua;../lua/?.lua;../lua/?/init.lua"
            $env:LUA_CPATH = "?.dll;?/init.dll;../lua/?.dll;../lua/?/init.dll"

            # Run the test
            nvim --headless -c "lua require('test.lua.test_print_table')" -c "quit"
            if ($LASTEXITCODE -ne 0) {
              throw "Test failed with exit code $LASTEXITCODE"
            }
          } catch {
            Write-Error $_.Exception.Message
            exit 1
          }

      - name: Run Lua tests (macOS)
        if: inputs.platform == 'macos'
        shell: bash
        run: |
          set -e
          source "${{ inputs.venv_path }}/bin/activate"

          # Install Neovim if not present
          if ! command -v nvim &> /dev/null; then
            echo "Installing Neovim..."
            brew install neovim
          fi

          # Verify Neovim is available
          if ! command -v nvim &> /dev/null; then
            echo "Error: Neovim not found in PATH after installation"
            echo "Current PATH: $PATH"
            echo "Homebrew prefix: $(brew --prefix)"
            echo "Homebrew bin: $(brew --prefix)/bin"
            exit 1
          fi
          echo "Using Neovim from: $(which nvim)"

          # Set up Lua environment
          export LUA_PATH="?.lua;?/init.lua;../lua/?.lua;../lua/?/init.lua"
          export LUA_CPATH="?.so;?/init.so;../lua/?.so;../lua/?/init.so"

          # Run the test
          nvim --headless -c "lua require('test.lua.test_print_table')" -c "quit"
          if [ $? -ne 0 ]; then
            echo "Error: Test failed with exit code $?"
            exit 1
          fi

      - name: Check formatting (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            & "${{ inputs.venv_path }}/Scripts/activate.ps1"
            # Ensure stylua is in PATH
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
            $env:Path = "$env:Path;$env:USERPROFILE\.cargo\bin"

            # Verify stylua is available
            $styluaPath = Get-Command stylua -ErrorAction SilentlyContinue
            if (-not $styluaPath) {
              throw "stylua not found in PATH. Current PATH: $env:Path"
            }
            Write-Output "Using stylua from: $($styluaPath.Source)"

            # Check formatting
            stylua --check lua/
            if ($LASTEXITCODE -ne 0) {
              throw "Format check failed for lua/ directory"
            }
            stylua --check after/plugin/
            if ($LASTEXITCODE -ne 0) {
              throw "Format check failed for after/plugin/ directory"
            }
          } catch {
            Write-Error $_.Exception.Message
            exit 1
          }

      - name: Check formatting (macOS)
        if: inputs.platform == 'macos'
        shell: bash
        run: |
          set -e
          source "${{ inputs.venv_path }}/bin/activate"

          # Verify stylua is available
          if ! command -v stylua &> /dev/null; then
            echo "Error: stylua not found in PATH"
            echo "Current PATH: $PATH"
            exit 1
          fi
          echo "Using stylua from: $(which stylua)"

          # Check formatting
          stylua --check lua/
          if [ $? -ne 0 ]; then
            echo "Error: Format check failed for lua/ directory"
            exit 1
          fi
          stylua --check after/plugin/
          if [ $? -ne 0 ]; then
            echo "Error: Format check failed for after/plugin/ directory"
            exit 1
          fi

      - name: Run sanity tests (Windows)
        if: inputs.install_deps && inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            # Validate environment variables
            $requiredEnvVars = @{
              'USERPROFILE' = $env:USERPROFILE
              'GITHUB_WORKSPACE' = $env:GITHUB_WORKSPACE
            }

            foreach ($var in $requiredEnvVars.GetEnumerator()) {
              if (-not $var.Value) {
                throw "Required environment variable not set: $($var.Key)"
              }
            }

            # Set and validate PATH
            $pathComponents = @(
              [System.Environment]::GetEnvironmentVariable("Path","Machine"),
              [System.Environment]::GetEnvironmentVariable("Path","User"),
              "C:\tools\neovim\nvim-win64\bin",
              "$env:USERPROFILE\.cargo\bin"
            )

            $env:Path = ($pathComponents | Where-Object { $_ -and (Test-Path $_) } | Select-Object -Unique) -join ';'

            # Activate virtual environment
            & "${{ inputs.venv_path }}/Scripts/activate.ps1"

            # Verify tools are available
            $requiredTools = @("nvim", "stylua")
            foreach ($tool in $requiredTools) {
              if (-not (Get-Command $tool -ErrorAction SilentlyContinue)) {
                throw "Required tool not found: $tool"
              }
              Write-Output "Verified tool: $tool"
            }

            Write-Output "Running sanity tests..."
            $timeout = 300 # 5 minutes

            # Basic functionality test
            Write-Output "Testing basic functionality..."
            $job = Start-Job -ScriptBlock {
              nvim --headless -c "quit" 2>&1
            }
            $result = Wait-Job $job -Timeout $timeout
            if ($result -eq $null) {
              Stop-Job $job
              throw "Basic functionality test timed out"
            }
            $output = Receive-Job $job
            if ($job.State -eq 'Failed') {
              throw "Basic functionality test failed: $output"
            }

            # Health check
            Write-Output "Running health check..."
            $job = Start-Job -ScriptBlock {
              nvim --headless -c "checkhealth" -c "quit" 2>&1
            }
            $result = Wait-Job $job -Timeout $timeout
            if ($result -eq $null) {
              Stop-Job $job
              throw "Health check timed out"
            }
            $output = Receive-Job $job
            if ($job.State -eq 'Failed') {
              throw "Health check failed: $output"
            }
            Write-Output $output

            # Core plugins test with retries
            Write-Output "Testing core plugins..."
            $plugins = @("lazy", "treesitter", "lsp", "mason", "telescope")
            foreach ($plugin in $plugins) {
              $maxRetries = 3
              $retryCount = 0
              $success = $false

              while (-not $success -and $retryCount -lt $maxRetries) {
                $job = Start-Job -ScriptBlock {
                  param($plugin)
                  nvim --headless -c "lua require('$plugin')" -c "quit" 2>&1
                } -ArgumentList $plugin

                $result = Wait-Job $job -Timeout $timeout
                if ($result -eq $null) {
                  Stop-Job $job
                  throw "Plugin $plugin test timed out"
                }

                $output = Receive-Job $job
                if ($job.State -eq 'Failed') {
                  $retryCount++
                  if ($retryCount -eq $maxRetries) {
                    throw "Plugin $plugin test failed after $maxRetries attempts: $output"
                  }
                  Write-Output "Retrying $plugin test (attempt $retryCount of $maxRetries)..."
                  Start-Sleep -Seconds (2 ** $retryCount)
                } else {
                  $success = $true
                }
              }
            }

            Write-Output "All tests completed successfully"

          } catch {
            $errorDetails = @{
              Message = $_.Exception.Message
              ScriptStackTrace = $_.ScriptStackTrace
              Time = Get-Date
              Environment = @{
                Path = $env:Path
                CurrentDirectory = Get-Location
                DirectoryContents = Get-ChildItem
              }
            }
            Write-Output ($errorDetails | ConvertTo-Json)
            exit 1
          }

      - name: Run sanity tests (macOS)
        if: inputs.install_deps && inputs.platform == 'macos'
        shell: bash
        run: |
          source "${{ inputs.venv_path }}/bin/activate"

          # Run tests and capture output
          test_output=$(bash infra/nvim_sanity_test.sh 2>&1)
          test_exit_code=$?

          # Display test results
          echo "Test results:"
          echo "$test_output"

          # Exit with the test exit code
          exit $test_exit_code
