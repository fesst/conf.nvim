name: Test Steps

on:
  workflow_call:
    inputs:
      platform:
        required: true
        type: string
        description: "Platform (macos/windows)"
      venv_path:
        required: true
        type: string
        description: "Path to virtual environment"
      use_cache:
        required: false
        type: boolean
        default: false
        description: "Whether to use caching for packages"
      install_deps:
        required: false
        type: boolean
        default: false
        description: "Whether to install minimal dependencies"

jobs:
  run-tests:
    runs-on: ${{ inputs.platform }}-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Verify virtual environment path
        shell: bash
        if: inputs.platform != 'windows'
        run: |
          echo "Checking virtual environment at: ${{ inputs.venv_path }}"
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la

          # Try to find the virtual environment if the exact path doesn't exist
          if [ ! -d "${{ inputs.venv_path }}" ]; then
            echo "Virtual environment not found at exact path, searching in common locations..."
            # Check common virtual environment locations
            VENV_LOCATIONS=(
              "${{ inputs.venv_path }}"
              "${{ runner.tool_cache }}/venv"
              "${{ runner.tool_cache }}/Python/3.13.3/venv"
              "${{ runner.tool_cache }}/Python/3.13.3/x64/venv"
              "/opt/hostedtoolcache/Python/3.13.3/venv"
              "/opt/hostedtoolcache/Python/3.13.3/x64/venv"
              "/Users/runner/hostedtoolcache/Python/3.13.3/venv"
              "/Users/runner/hostedtoolcache/Python/3.13.3/x64/venv"
            )

            for venv_path in "${VENV_LOCATIONS[@]}"; do
              echo "Checking location: $venv_path"
              if [ -d "$venv_path" ]; then
                echo "Found virtual environment at: $venv_path"
                echo "virtual_env=$venv_path" >> $GITHUB_OUTPUT
                break
              fi
            done

            if [ ! -d "$VIRTUAL_ENV" ]; then
              echo "Error: Virtual environment not found in any common locations"
              echo "Checked locations:"
              printf '%s\n' "${VENV_LOCATIONS[@]}"
              echo "Python version: $(python3 --version)"
              echo "Python path: $(which python3)"
              echo "PATH: $PATH"
              exit 1
            fi
          else
            echo "Virtual environment found at: ${{ inputs.venv_path }}"
            echo "virtual_env=${{ inputs.venv_path }}" >> $GITHUB_OUTPUT
          fi

          echo "Virtual environment contents:"
          ls -la "$VIRTUAL_ENV"

      - name: Verify virtual environment path (Windows)
        shell: pwsh
        if: inputs.platform == 'windows'
        run: |
          Write-Output "Checking virtual environment at: ${{ inputs.venv_path }}"
          if (-not (Test-Path "${{ inputs.venv_path }}")) {
            Write-Output "Virtual environment not found at exact path, searching in common locations..."
            # Check common virtual environment locations
            $VENV_LOCATIONS = @(
              "${{ inputs.venv_path }}"
              "${{ runner.tool_cache }}\venv"
              "${{ runner.tool_cache }}\Python\3.13.3\venv"
              "${{ runner.tool_cache }}\Python\3.13.3\x64\venv"
              "C:\hostedtoolcache\windows\Python\3.13.3\venv"
              "C:\hostedtoolcache\windows\Python\3.13.3\x64\venv"
            )

            foreach ($venv_path in $VENV_LOCATIONS) {
              Write-Output "Checking location: $venv_path"
              if (Test-Path $venv_path) {
                Write-Output "Found virtual environment at: $venv_path"
                "virtual_env=$venv_path" >> $env:GITHUB_OUTPUT
                break
              }
            }

            if (-not (Test-Path $env:VIRTUAL_ENV)) {
              Write-Error "Virtual environment not found in any common locations"
              Write-Output "Checked locations:"
              $VENV_LOCATIONS | ForEach-Object { Write-Output $_ }
              Write-Output "Python version: $(python --version)"
              Write-Output "Python path: $(Get-Command python).Source"
              Write-Output "PATH: $env:Path"
              exit 1
            }
          } else {
            Write-Output "Virtual environment found at: ${{ inputs.venv_path }}"
            "virtual_env=${{ inputs.venv_path }}" >> $env:GITHUB_OUTPUT
          }

      - name: Log Python venv cache info
        shell: bash
        run: |
          echo "=== Python venv Cache Info ==="
          echo "Cache path: ${{ steps.venv-mac.outputs.virtual_env }}"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-venv-${{ hashFiles('infra/packages/pip.sh', '**/requirements.txt') }}"
          echo "Cache size: $(du -sh ${{ steps.venv-mac.outputs.virtual_env }} 2>/dev/null || echo 'Not found')"
          echo "==========================="

      - name: Restore Python venv from cache
        uses: actions/cache@v4
        id: python-venv-cache
        with:
          path: ${{ steps.venv-mac.outputs.virtual_env }}
          key: ${{ runner.os }}-${{ runner.arch }}-venv-${{ hashFiles('infra/packages/pip.sh', '**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-venv-

      - name: Log Python venv cache result
        shell: bash
        run: |
          echo "=== Python venv Cache Result ==="
          echo "Cache hit: ${{ steps.python-venv-cache.outputs.cache-hit }}"
          echo "Cache size after restore: $(du -sh ${{ steps.venv-mac.outputs.virtual_env }} 2>/dev/null || echo 'Not found')"
          echo "=============================="

      - name: Log Homebrew cache info
        if: inputs.platform == 'macos' && inputs.use_cache
        shell: bash
        run: |
          echo "=== Homebrew Cache Info ==="
          echo "Cache paths:"
          echo "- ~/Library/Caches/Homebrew"
          echo "- /usr/local/Homebrew"
          echo "- /opt/homebrew"
          echo "- ~/Library/Logs/Homebrew"
          echo "- /opt/homebrew/Library/Caches"
          echo "- /opt/homebrew/Library/Logs"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-homebrew-${{ hashFiles('infra/packages/brew.sh') }}"
          echo "========================="

      - name: Cache Homebrew packages
        if: inputs.platform == 'macos' && inputs.use_cache
        uses: actions/cache@v4
        id: homebrew-cache
        with:
          path: |
            ~/Library/Caches/Homebrew
            /usr/local/Homebrew
            /opt/homebrew
            ~/Library/Logs/Homebrew
            /opt/homebrew/Library/Caches
            /opt/homebrew/Library/Logs
          key: ${{ runner.os }}-${{ runner.arch }}-homebrew-${{ hashFiles('infra/packages/brew.sh') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-homebrew-

      - name: Log Homebrew cache result
        if: inputs.platform == 'macos' && inputs.use_cache
        shell: bash
        run: |
          echo "=== Homebrew Cache Result ==="
          echo "Cache hit: ${{ steps.homebrew-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          du -sh ~/Library/Caches/Homebrew /usr/local/Homebrew /opt/homebrew 2>/dev/null || echo "Not found"
          echo "==========================="

      - name: Log LuaRocks cache info
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== LuaRocks Cache Info ==="
          echo "Cache paths:"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.cache\\luarocks', env.USERPROFILE) || '~/.cache/luarocks' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.luarocks', env.USERPROFILE) || '~/.luarocks' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\luarocks', env.USERPROFILE) || '~/.local/share/luarocks' }}"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-luarocks-${{ hashFiles('infra/packages/luarocks.sh') }}"
          echo "========================="

      - name: Cache LuaRocks packages
        if: inputs.use_cache
        uses: actions/cache@v4
        id: luarocks-cache
        with:
          path: |
            ${{ runner.os == 'Windows' && format('{0}\\.cache\\luarocks', env.USERPROFILE) || '~/.cache/luarocks' }}
            ${{ runner.os == 'Windows' && format('{0}\\.luarocks', env.USERPROFILE) || '~/.luarocks' }}
            ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\luarocks', env.USERPROFILE) || '~/.local/share/luarocks' }}
          key: ${{ runner.os }}-${{ runner.arch }}-luarocks-${{ hashFiles('infra/packages/luarocks.sh') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-luarocks-

      - name: Log LuaRocks cache result
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== LuaRocks Cache Result ==="
          echo "Cache hit: ${{ steps.luarocks-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          if [ "${{ runner.os }}" == "Windows" ]; then
            du -sh "${{ format('{0}\\.cache\\luarocks', env.USERPROFILE) }}" "${{ format('{0}\\.luarocks', env.USERPROFILE) }}" "${{ format('{0}\\.local\\share\\luarocks', env.USERPROFILE) }}" 2>/dev/null || echo "Not found"
          else
            du -sh ~/.cache/luarocks ~/.luarocks ~/.local/share/luarocks 2>/dev/null || echo "Not found"
          fi
          echo "==========================="

      - name: Log Neovim plugins cache info
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== Neovim Plugins Cache Info ==="
          echo "Cache paths:"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\nvim', env.USERPROFILE) || '~/.local/share/nvim' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) || '~/.config/nvim/plugin' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) || '~/.config/nvim/lazy' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\state\\nvim', env.USERPROFILE) || '~/.local/state/nvim' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.cache\\nvim', env.USERPROFILE) || '~/.cache/nvim' }}"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-nvim-plugins-${{ hashFiles('lua/**/*.lua', 'after/plugin/**/*.lua', 'infra/packages/nvim.sh') }}"
          echo "=============================="

      - name: Cache Neovim plugins
        if: inputs.use_cache
        uses: actions/cache@v4
        id: nvim-plugins-cache
        with:
          path: |
            ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\nvim', env.USERPROFILE) || '~/.local/share/nvim' }}
            ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) || '~/.config/nvim/plugin' }}
            ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) || '~/.config/nvim/lazy' }}
            ${{ runner.os == 'Windows' && format('{0}\\.local\\state\\nvim', env.USERPROFILE) || '~/.local/state/nvim' }}
            ${{ runner.os == 'Windows' && format('{0}\\.cache\\nvim', env.USERPROFILE) || '~/.cache/nvim' }}
          key: ${{ runner.os }}-${{ runner.arch }}-nvim-plugins-${{ hashFiles('lua/**/*.lua', 'after/plugin/**/*.lua', 'infra/packages/nvim.sh') }}

      - name: Log Neovim plugins cache result
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== Neovim Plugins Cache Result ==="
          echo "Cache hit: ${{ steps.nvim-plugins-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          if [ "${{ runner.os }}" == "Windows" ]; then
            du -sh "${{ format('{0}\\.local\\share\\nvim', env.USERPROFILE) }}" "${{ format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) }}" "${{ format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) }}" 2>/dev/null || echo "Not found"
          else
            du -sh ~/.local/share/nvim ~/.config/nvim/plugin ~/.config/nvim/lazy 2>/dev/null || echo "Not found"
          fi
          echo "================================"

      - name: Install minimal dependencies (Windows)
        if: inputs.install_deps && inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            # Normalize the virtual environment path
            $venvPath = [System.IO.Path]::GetFullPath("${{ steps.venv-mac.outputs.virtual_env }}")
            Write-Output "Using virtual environment at: $venvPath"

            # Verify virtual environment exists
            if (-not (Test-Path $venvPath)) {
              throw "Virtual environment not found at: $venvPath"
            }

            # Verify activation script exists
            $activateScript = Join-Path $venvPath "Scripts\activate.ps1"
            if (-not (Test-Path $activateScript)) {
              throw "Activation script not found at: $activateScript"
            }

            # Activate virtual environment
            Write-Output "Activating virtual environment..."
            & $activateScript
            if ($LASTEXITCODE -ne 0) {
              throw "Failed to activate virtual environment"
            }

            # Verify Python is available
            $pythonPath = Get-Command python -ErrorAction SilentlyContinue
            if (-not $pythonPath) {
              throw "Python not found in PATH after activation"
            }
            Write-Output "Using Python from: $($pythonPath.Source)"

            # Run install script
            $env:CI = "true"
            Write-Output "Running install script..."
            bash infra/install.sh
          } catch {
            Write-Error $_.Exception.Message
            Write-Output "Current directory: $(Get-Location)"
            Write-Output "Directory contents: $(Get-ChildItem)"
            Write-Output "Environment variables:"
            Get-ChildItem env: | Format-Table -AutoSize
            exit 1
          }

      - name: Install minimal dependencies (macOS)
        if: inputs.install_deps && inputs.platform == 'macos'
        shell: bash
        run: |
          set -e
          # Verify virtual environment path
          if [ ! -d "${{ steps.venv-mac.outputs.virtual_env }}" ]; then
            echo "Error: Virtual environment not found at: ${{ steps.venv-mac.outputs.virtual_env }}"
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -la
            exit 1
          fi

          # Verify activation script exists
          if [ ! -f "${{ steps.venv-mac.outputs.virtual_env }}/bin/activate" ]; then
            echo "Error: Activation script not found at: ${{ steps.venv-mac.outputs.virtual_env }}/bin/activate"
            echo "Virtual environment contents:"
            ls -la "${{ steps.venv-mac.outputs.virtual_env }}/bin"
            exit 1
          fi

          # Retry brew install with exponential backoff
          for i in {1..3}; do
            if brew install neovim tree-sitter; then
              break
            fi
            if [ $i -eq 3 ]; then
              echo "Failed to install dependencies after 3 attempts"
              exit 1
            fi
            sleep $((2 ** i))
          done

          # Activate virtual environment with error handling
          echo "Activating virtual environment at: ${{ steps.venv-mac.outputs.virtual_env }}"
          source "${{ steps.venv-mac.outputs.virtual_env }}/bin/activate" || {
            echo "Error: Failed to activate virtual environment"
            echo "Python version: $(python --version)"
            echo "PATH: $PATH"
            exit 1
          }

          # Verify Python is available after activation
          if ! command -v python &> /dev/null; then
            echo "Error: Python not found in PATH after activation"
            echo "PATH: $PATH"
            exit 1
          fi

          export CI=true
          bash infra/install.sh

      - name: Run Lua tests (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            & "${{ steps.venv-mac.outputs.virtual_env }}/Scripts/activate.ps1"
            # Ensure Neovim is in PATH and verify it
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
            $env:Path = "$env:Path;C:\tools\neovim\nvim-win64\bin"

            # Verify Neovim is available
            $nvimPath = Get-Command nvim -ErrorAction SilentlyContinue
            if (-not $nvimPath) {
              throw "Neovim not found in PATH before running tests. Current PATH: $env:Path"
            }
            Write-Output "Using Neovim from: $($nvimPath.Source)"

            # Set up Lua environment
            $env:LUA_PATH = "?.lua;?/init.lua;../lua/?.lua;../lua/?/init.lua"
            $env:LUA_CPATH = "?.dll;?/init.dll;../lua/?.dll;../lua/?/init.dll"

            # Run the test
            nvim --headless -c "lua require('test.lua.test_print_table')" -c "quit"
            if ($LASTEXITCODE -ne 0) {
              throw "Test failed with exit code $LASTEXITCODE"
            }
          } catch {
            Write-Error $_.Exception.Message
            exit 1
          }

      - name: Run Lua tests (macOS)
        if: inputs.platform == 'macos'
        shell: bash
        run: |
          set -e
          source "${{ steps.venv-mac.outputs.virtual_env }}/bin/activate"

          # Verify Neovim is available
          if ! command -v nvim &> /dev/null; then
            echo "Error: Neovim not found in PATH before running tests"
            echo "Current PATH: $PATH"
            exit 1
          fi
          echo "Using Neovim from: $(which nvim)"

          # Set up Lua environment
          export LUA_PATH="?.lua;?/init.lua;../lua/?.lua;../lua/?/init.lua"
          export LUA_CPATH="?.so;?/init.so;../lua/?.so;../lua/?/init.so"

          # Run the test
          nvim --headless -c "lua require('test.lua.test_print_table')" -c "quit"
          if [ $? -ne 0 ]; then
            echo "Error: Test failed with exit code $?"
            exit 1
          fi

      - name: Check formatting (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            & "${{ steps.venv-mac.outputs.virtual_env }}/Scripts/activate.ps1"
            # Ensure stylua is in PATH
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
            $env:Path = "$env:Path;$env:USERPROFILE\.cargo\bin"

            # Verify stylua is available
            $styluaPath = Get-Command stylua -ErrorAction SilentlyContinue
            if (-not $styluaPath) {
              throw "stylua not found in PATH. Current PATH: $env:Path"
            }
            Write-Output "Using stylua from: $($styluaPath.Source)"

            # Check formatting
            stylua --check lua/
            if ($LASTEXITCODE -ne 0) {
              throw "Format check failed for lua/ directory"
            }
            stylua --check after/plugin/
            if ($LASTEXITCODE -ne 0) {
              throw "Format check failed for after/plugin/ directory"
            }
          } catch {
            Write-Error $_.Exception.Message
            exit 1
          }

      - name: Check formatting (macOS)
        if: inputs.platform == 'macos'
        shell: bash
        run: |
          set -e
          source "${{ steps.venv-mac.outputs.virtual_env }}/bin/activate"

          # Verify stylua is available
          if ! command -v stylua &> /dev/null; then
            echo "Error: stylua not found in PATH"
            echo "Current PATH: $PATH"
            exit 1
          fi
          echo "Using stylua from: $(which stylua)"

          # Check formatting
          stylua --check lua/
          if [ $? -ne 0 ]; then
            echo "Error: Format check failed for lua/ directory"
            exit 1
          fi
          stylua --check after/plugin/
          if [ $? -ne 0 ]; then
            echo "Error: Format check failed for after/plugin/ directory"
            exit 1
          fi

      - name: Run sanity tests (Windows)
        if: inputs.install_deps && inputs.platform == 'windows'
        shell: pwsh
        run: |
          & "${{ steps.venv-mac.outputs.virtual_env }}/Scripts/activate.ps1"
          # Ensure all tools are in PATH
          $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          $env:Path = "$env:Path;C:\tools\neovim\nvim-win64\bin;$env:USERPROFILE\.cargo\bin"

          # Run tests and capture output
          $testOutput = & bash infra/nvim_sanity_test.sh 2>&1
          $test_exit_code = $LASTEXITCODE

          # Display test results
          Write-Output "Test results:"
          $testOutput

          # Exit with the test exit code
          exit $test_exit_code

      - name: Run sanity tests (macOS)
        if: inputs.install_deps && inputs.platform == 'macos'
        shell: bash
        run: |
          source "${{ steps.venv-mac.outputs.virtual_env }}/bin/activate"

          # Run tests and capture output
          test_output=$(bash infra/nvim_sanity_test.sh 2>&1)
          test_exit_code=$?

          # Display test results
          echo "Test results:"
          echo "$test_output"

          # Exit with the test exit code
          exit $test_exit_code
