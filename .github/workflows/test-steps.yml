name: Test Steps

on:
  workflow_call:
    inputs:
      platform:
        required: true
        type: string
        description: "Platform (macos/windows)"
      venv_path:
        required: true
        type: string
        description: "Path to virtual environment"
      use_cache:
        required: false
        type: boolean
        default: false
        description: "Whether to use caching for packages"
      install_deps:
        required: false
        type: boolean
        default: false
        description: "Whether to install minimal dependencies"
      setup_python:
        required: false
        type: boolean
        default: false
        description: "Whether to use the setup file for virtual environment"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.job }}-${{ github.run_id }}
  cancel-in-progress: true

jobs:
  run-tests:
    runs-on: ${{ inputs.platform }}-latest
    steps:
      - name: Debug environment
        shell: bash
        run: |
          echo "=== Environment Debug Info ==="
          echo "Platform: ${{ inputs.platform }}"
          echo "venv_path: ${{ inputs.venv_path }}"
          echo "use_cache: ${{ inputs.use_cache }}"
          echo "install_deps: ${{ inputs.install_deps }}"
          echo "setup_python: ${{ inputs.setup_python }}"
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          echo "==========================="

      - name: Debug Windows environment
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Windows Environment Debug Info ==="
          Write-Output "Current directory: $(Get-Location)"
          Write-Output "Directory contents:"
          Get-ChildItem
          Write-Output "Environment variables:"
          Get-ChildItem env: | Format-Table -AutoSize
          Write-Output "PATH: $env:Path"
          Write-Output "Python version: $(python --version)"
          Write-Output "================================"

      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Log Python venv cache info
        shell: bash
        run: |
          echo "=== Python venv Cache Info ==="
          echo "Cache path: ${{ runner.tool_cache }}/venv"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-venv-${{ hashFiles('infra/packages/pip.sh', 'infra/packages/pip.ps1') }}"
          echo "Cache size: $(du -sh ${{ runner.tool_cache }}/venv 2>/dev/null || echo 'Not found')"
          echo "==========================="

      - name: Restore Python venv from cache
        uses: actions/cache@v4
        id: python-venv-cache
        with:
          path: ${{ runner.tool_cache }}/venv
          key: ${{ runner.os }}-${{ runner.arch }}-venv-${{ hashFiles('infra/packages/pip.sh', 'infra/packages/pip.ps1') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-venv-

      - name: Log Python venv cache result
        shell: bash
        run: |
          echo "=== Python venv Cache Result ==="
          echo "Cache hit: ${{ steps.python-venv-cache.outputs.cache-hit }}"
          echo "Cache size after restore: $(du -sh ${{ runner.tool_cache }}/venv 2>/dev/null || echo 'Not found')"
          echo "=============================="

      - name: Activate virtual environment
        shell: bash
        run: |
          set -e
          VENV_PATH="${{ inputs.venv_path }}"

          # Debug information
          echo "=== Virtual Environment Activation ==="
          echo "VENV_PATH: $VENV_PATH"
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la

          # Check if virtual environment exists
          if [ ! -d "$VENV_PATH" ]; then
            echo "Error: Virtual environment not found at: $VENV_PATH"
            exit 1
          fi

          # Activate virtual environment
          if [ "${{ runner.os }}" == "Windows" ]; then
            source "$VENV_PATH/Scripts/activate"
          else
            source "$VENV_PATH/bin/activate"
          fi

          # Verify activation
          which python
          python --version
          echo "================================"

      - name: Log Rust cache info
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Rust Cache Info ==="
          Write-Output "Cache paths:"
          Write-Output "- $env:USERPROFILE\.cargo"
          Write-Output "- $env:USERPROFILE\.rustup"
          Write-Output "Cache key: ${{ runner.os }}-${{ runner.arch }}-rust-${{ hashFiles('infra/packages/cargo.sh', 'infra/packages/cargo.ps1') }}"
          Write-Output "========================="

      - name: Cache Rust
        if: inputs.platform == 'windows'
        uses: actions/cache@v4
        id: rust-cache
        with:
          path: |
            ${{ runner.os == 'Windows' && format('{0}\\.cargo', env.USERPROFILE) || '~/.cargo' }}
            ${{ runner.os == 'Windows' && format('{0}\\.rustup', env.USERPROFILE) || '~/.rustup' }}
          key: ${{ runner.os }}-${{ runner.arch }}-rust-${{ hashFiles('infra/packages/cargo.sh', 'infra/packages/cargo.ps1') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-rust-

      - name: Log Rust cache result
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Rust Cache Result ==="
          Write-Output "Cache hit: ${{ steps.rust-cache.outputs.cache-hit }}"
          Write-Output "Cache sizes:"
          if (Test-Path "$env:USERPROFILE\.cargo") {
              Get-ChildItem "$env:USERPROFILE\.cargo" -Recurse | Measure-Object -Property Length -Sum | Select-Object @{Name="Size(MB)";Expression={"{0:N2}" -f ($_.Sum / 1MB)}}
          }
          if (Test-Path "$env:USERPROFILE\.rustup") {
              Get-ChildItem "$env:USERPROFILE\.rustup" -Recurse | Measure-Object -Property Length -Sum | Select-Object @{Name="Size(MB)";Expression={"{0:N2}" -f ($_.Sum / 1MB)}}
          }
          Write-Output "==========================="

      - name: Log Visual Studio Build Tools cache info
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Visual Studio Build Tools Cache Info ==="
          Write-Output "Cache paths:"
          Write-Output "- $env:USERPROFILE\vs_buildtools"
          Write-Output "Cache key: ${{ runner.os }}-${{ runner.arch }}-vstools-${{ hashFiles('infra/packages/vs-setup.ps1') }}"
          Write-Output "========================="

      - name: Cache Visual Studio Build Tools
        if: inputs.platform == 'windows'
        uses: actions/cache@v4
        id: vstools-cache
        with:
          path: ${{ runner.os == 'Windows' && format('{0}\\vs_buildtools', env.USERPROFILE) || '~/vs_buildtools' }}
          key: ${{ runner.os }}-${{ runner.arch }}-vstools-${{ hashFiles('infra/packages/vs-setup.ps1') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-vstools-

      - name: Log Visual Studio Build Tools cache result
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Visual Studio Build Tools Cache Result ==="
          Write-Output "Cache hit: ${{ steps.vstools-cache.outputs.cache-hit }}"
          Write-Output "Cache size:"
          if (Test-Path "$env:USERPROFILE\vs_buildtools") {
              Get-ChildItem "$env:USERPROFILE\vs_buildtools" -Recurse | Measure-Object -Property Length -Sum | Select-Object @{Name="Size(MB)";Expression={"{0:N2}" -f ($_.Sum / 1MB)}}
          }
          Write-Output "==========================="

      - name: Verify Rust installation
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            $ErrorActionPreference = 'Stop'
            Write-Output "Verifying Rust installation..."

            # Check if rustup is available
            $rustupPath = Get-Command rustup -ErrorAction SilentlyContinue
            if (-not $rustupPath) {
                Write-Output "rustup not found, installing Rust..."
                Invoke-WebRequest -Uri https://win.rustup.rs -OutFile rustup-init.exe
                .\rustup-init.exe -y
                Remove-Item rustup-init.exe
                $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
                $env:Path = "$env:Path;$env:USERPROFILE\.cargo\bin"
            }

            # Verify rustc and cargo
            $rustcVersion = rustc --version
            $cargoVersion = cargo --version
            Write-Output "Rust version: $rustcVersion"
            Write-Output "Cargo version: $cargoVersion"

            # Install stylua if not present
            $styluaPath = Get-Command stylua -ErrorAction SilentlyContinue
            if (-not $styluaPath) {
                Write-Output "Installing stylua..."
                cargo install stylua
            }
          } catch {
            Write-Error $_.Exception.Message
            Write-Output "Current PATH: $env:Path"
            exit 1
          }

      - name: Verify Visual Studio Build Tools
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            $ErrorActionPreference = 'Stop'
            Write-Output "Verifying Visual Studio Build Tools..."

            $vsPath = Join-Path $env:USERPROFILE "vs_buildtools"
            $vsDevCmd = Join-Path $vsPath "Common7\Tools\VsDevCmd.bat"

            if (-not (Test-Path $vsDevCmd)) {
                Write-Output "Visual Studio Build Tools not found, installing..."

                # Create installation directory
                if (-not (Test-Path $vsPath)) {
                    New-Item -ItemType Directory -Path $vsPath -Force | Out-Null
                }

                # Download VS Build Tools installer
                $vsInstallerUrl = "https://aka.ms/vs/16/release/vs_buildtools.exe"
                $vsInstallerPath = "$env:TEMP\vs_buildtools.exe"
                Write-Output "Downloading VS Build Tools installer..."
                Invoke-WebRequest -Uri $vsInstallerUrl -OutFile $vsInstallerPath -UseBasicParsing

                # Install VS Build Tools
                Write-Output "Installing VS Build Tools..."
                $process = Start-Process -FilePath $vsInstallerPath -ArgumentList @(
                    "--quiet",
                    "--wait",
                    "--norestart",
                    "--nocache",
                    "--installPath", $vsPath,
                    "--add", "Microsoft.VisualStudio.Workload.VCTools",
                    "--includeRecommended"
                ) -Wait -PassThru

                if ($process.ExitCode -ne 0) {
                    throw "Failed to install Visual Studio Build Tools. Exit code: $($process.ExitCode)"
                }
            }

            # Set up Visual Studio environment
            Write-Output "Setting up Visual Studio environment..."
            cmd /c "`"$vsDevCmd`" && set" | ForEach-Object {
                if ($_ -match "^(.*?)=(.*)$") {
                    $name = $matches[1]
                    $value = $matches[2]
                    [System.Environment]::SetEnvironmentVariable($name, $value, [System.EnvironmentVariableTarget]::Process)
                }
            }

            # Verify installation
            $clPath = (Get-Command cl.exe -ErrorAction SilentlyContinue).Source
            if (-not $clPath) {
                throw "Failed to set up Visual Studio environment. cl.exe not found."
            }
            Write-Output "Visual Studio Build Tools verified successfully"
          } catch {
            Write-Error $_.Exception.Message
            Write-Output "Current PATH: $env:Path"
            exit 1
          }

      - name: Log Homebrew cache info
        if: inputs.platform == 'macos' && inputs.use_cache
        shell: bash
        run: |
          echo "=== Homebrew Cache Info ==="
          echo "Cache paths:"
          echo "- ~/Library/Caches/Homebrew"
          echo "- /usr/local/Homebrew"
          echo "- /opt/homebrew"
          echo "- ~/Library/Logs/Homebrew"
          echo "- /opt/homebrew/Library/Caches"
          echo "- /opt/homebrew/Library/Logs"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-homebrew-${{ hashFiles('infra/packages/brew.sh') }}"
          echo "========================="

      - name: Cache Homebrew packages
        if: inputs.platform == 'macos' && inputs.use_cache
        uses: actions/cache@v4
        id: homebrew-cache
        with:
          path: |
            ~/Library/Caches/Homebrew
            /usr/local/Homebrew
            /opt/homebrew
            ~/Library/Logs/Homebrew
            /opt/homebrew/Library/Caches
            /opt/homebrew/Library/Logs
          key: ${{ runner.os }}-${{ runner.arch }}-homebrew-${{ hashFiles('infra/packages/brew.sh') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-homebrew-

      - name: Log Homebrew cache result
        if: inputs.platform == 'macos' && inputs.use_cache
        shell: bash
        run: |
          echo "=== Homebrew Cache Result ==="
          echo "Cache hit: ${{ steps.homebrew-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          du -sh ~/Library/Caches/Homebrew /usr/local/Homebrew /opt/homebrew 2>/dev/null || echo "Not found"
          echo "==========================="

      - name: Log LuaRocks cache info
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== LuaRocks Cache Info ==="
          echo "Cache paths:"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.cache\\luarocks', env.USERPROFILE) || '~/.cache/luarocks' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.luarocks', env.USERPROFILE) || '~/.luarocks' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\luarocks', env.USERPROFILE) || '~/.local/share/luarocks' }}"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-luarocks-${{ hashFiles('infra/packages/luarocks.sh') }}"
          echo "========================="

      - name: Cache LuaRocks packages
        if: inputs.use_cache
        uses: actions/cache@v4
        id: luarocks-cache
        with:
          path: |
            ${{ runner.os == 'Windows' && format('{0}\\.cache\\luarocks', env.USERPROFILE) || '~/.cache/luarocks' }}
            ${{ runner.os == 'Windows' && format('{0}\\.luarocks', env.USERPROFILE) || '~/.luarocks' }}
            ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\luarocks', env.USERPROFILE) || '~/.local/share/luarocks' }}
          key: ${{ runner.os }}-${{ runner.arch }}-luarocks-${{ hashFiles('infra/packages/luarocks.sh') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-luarocks-

      - name: Log LuaRocks cache result
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== LuaRocks Cache Result ==="
          echo "Cache hit: ${{ steps.luarocks-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          if [ "${{ runner.os }}" == "Windows" ]; then
            du -sh "${{ format('{0}\\.cache\\luarocks', env.USERPROFILE) }}" "${{ format('{0}\\.luarocks', env.USERPROFILE) }}" "${{ format('{0}\\.local\\share\\luarocks', env.USERPROFILE) }}" 2>/dev/null || echo "Not found"
          else
            du -sh ~/.cache/luarocks ~/.luarocks ~/.local/share/luarocks 2>/dev/null || echo "Not found"
          fi
          echo "==========================="

      - name: Log Neovim plugins cache info
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== Neovim Plugins Cache Info ==="
          echo "Cache paths:"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\nvim', env.USERPROFILE) || '~/.local/share/nvim' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) || '~/.config/nvim/plugin' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) || '~/.config/nvim/lazy' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.local\\state\\nvim', env.USERPROFILE) || '~/.local/state/nvim' }}"
          echo "- ${{ runner.os == 'Windows' && format('{0}\\.cache\\nvim', env.USERPROFILE) || '~/.cache/nvim' }}"
          echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-nvim-plugins-${{ hashFiles('lua/**/*.lua', 'after/plugin/**/*.lua', 'infra/packages/nvim.sh') }}"
          echo "=============================="

      - name: Cache Neovim plugins
        if: inputs.use_cache
        uses: actions/cache@v4
        id: nvim-plugins-cache
        with:
          path: |
            ${{ runner.os == 'Windows' && format('{0}\\.local\\share\\nvim', env.USERPROFILE) || '~/.local/share/nvim' }}
            ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) || '~/.config/nvim/plugin' }}
            ${{ runner.os == 'Windows' && format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) || '~/.config/nvim/lazy' }}
            ${{ runner.os == 'Windows' && format('{0}\\.local\\state\\nvim', env.USERPROFILE) || '~/.local/state/nvim' }}
            ${{ runner.os == 'Windows' && format('{0}\\.cache\\nvim', env.USERPROFILE) || '~/.cache/nvim' }}
          key: ${{ runner.os }}-${{ runner.arch }}-nvim-plugins-${{ hashFiles('lua/**/*.lua', 'after/plugin/**/*.lua', 'infra/packages/nvim.sh') }}

      - name: Log Neovim plugins cache result
        if: inputs.use_cache
        shell: bash
        run: |
          echo "=== Neovim Plugins Cache Result ==="
          echo "Cache hit: ${{ steps.nvim-plugins-cache.outputs.cache-hit }}"
          echo "Cache sizes:"
          if [ "${{ runner.os }}" == "Windows" ]; then
            du -sh "${{ format('{0}\\.local\\share\\nvim', env.USERPROFILE) }}" "${{ format('{0}\\.config\\nvim\\plugin', env.USERPROFILE) }}" "${{ format('{0}\\.config\\nvim\\lazy', env.USERPROFILE) }}" 2>/dev/null || echo "Not found"
          else
            du -sh ~/.local/share/nvim ~/.config/nvim/plugin ~/.config/nvim/lazy 2>/dev/null || echo "Not found"
          fi
          echo "================================"

      - name: Install minimal dependencies (Windows)
        if: inputs.install_deps && inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            $ErrorActionPreference = 'Stop'
            $env:PYTHONIOENCODING = 'utf-8'  # Ensure proper encoding

            # Get the virtual environment path
            $venvPath = "${{ inputs.venv_path }}"
            Write-Output "Using virtual environment at: $venvPath"

            # Check if we're already in the virtual environment
            $currentPython = (Get-Command python | Select-Object -ExpandProperty Source)
            if ($currentPython.StartsWith($venvPath)) {
                Write-Output "Already in virtual environment at: $venvPath"
                Write-Output "Current Python: $currentPython"
            } else {
                # Normalize the path for Windows
                $venvPath = [System.IO.Path]::GetFullPath($venvPath)
                Write-Output "Normalized path: $venvPath"

                # Create parent directory if it doesn't exist
                $parentDir = Split-Path -Parent $venvPath
                if (-not (Test-Path $parentDir)) {
                    Write-Output "Creating parent directory: $parentDir"
                    New-Item -ItemType Directory -Path $parentDir -Force | Out-Null
                }

                # Verify virtual environment exists
                if (-not (Test-Path $venvPath)) {
                    Write-Error "Virtual environment not found at: $venvPath"
                    Write-Output "Current directory: $(Get-Location)"
                    Write-Output "Directory contents:"
                    Get-ChildItem | Format-Table -AutoSize
                    Write-Output "Parent directory contents:"
                    Get-ChildItem $parentDir | Format-Table -AutoSize
                    exit 1
                }

                # Verify activation script exists
                $activateScript = Join-Path $venvPath "Scripts\Activate.ps1"
                Write-Output "Checking activation script at: $activateScript"

                if (-not (Test-Path $activateScript)) {
                    Write-Error "Activation script not found at: $activateScript"
                    Write-Output "Virtual environment contents:"
                    Get-ChildItem $venvPath -Recurse | Format-Table -AutoSize
                    exit 1
                }

                # Set execution policy for the process
                Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

                # Activate virtual environment
                Write-Output "Activating virtual environment..."
                Write-Output "Current PATH before activation: $env:Path"
                Write-Output "Current Python before activation: $currentPython"

                # Source the activation script
                & $activateScript
                if ($LASTEXITCODE -ne 0) {
                    throw "Failed to activate virtual environment"
                }

                # Verify activation by checking Python path
                $pythonPath = (Get-Command python | Select-Object -ExpandProperty Source)
                if (-not $pythonPath.StartsWith($venvPath)) {
                    Write-Error "Python is not using the virtual environment"
                    Write-Output "Expected Python path to start with: $venvPath"
                    Write-Output "Actual Python path: $pythonPath"
                    Write-Output "Current PATH: $env:Path"
                    exit 1
                }
            }

            # Ensure Neovim is in PATH and verify it
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
            $env:Path = "$env:Path;C:\tools\neovim\nvim-win64\bin"

            # Verify Neovim is available
            $nvimPath = Get-Command nvim -ErrorAction SilentlyContinue
            if (-not $nvimPath) {
                throw "Neovim not found in PATH before running tests. Current PATH: $env:Path"
            }
            Write-Output "Using Neovim from: $($nvimPath.Source)"

            # Set up Lua environment
            $env:LUA_PATH = "?.lua;?/init.lua;../lua/?.lua;../lua/?/init.lua"
            $env:LUA_CPATH = "?.dll;?/init.dll;../lua/?.dll;../lua/?/init.dll"

            # Run the test
            nvim --headless -c "lua require('test.lua.test_print_table')" -c "quit"
            if ($LASTEXITCODE -ne 0) {
                throw "Test failed with exit code $LASTEXITCODE"
            }
          } catch {
            Write-Error $_.Exception.Message
            exit 1
          }

      - name: Install and verify Neovim (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Installing Neovim ==="

          # Install Neovim using winget
          winget install -e --id Neovim.Neovim
          if ($LASTEXITCODE -ne 0) {
              Write-Error "Failed to install Neovim"
              exit 1
          }

          # Add Neovim to PATH
          $neovimPath = "C:\Program Files\Neovim\bin"
          $env:Path = "$neovimPath;$env:Path"
          [Environment]::SetEnvironmentVariable("Path", $env:Path, [System.EnvironmentVariableTarget]::Process)

          # Verify Neovim installation
          Write-Output "Verifying Neovim installation..."
          nvim --version
          if ($LASTEXITCODE -ne 0) {
              Write-Error "Neovim not found in PATH after installation"
              Write-Output "Current PATH: $env:Path"
              exit 1
          }

          Write-Output "Neovim installed successfully"
          Write-Output "==========================="

      - name: Run lua tests (win)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          Write-Output "=== Running Lua Tests ==="

          # Set up Lua path
          $env:Path = "C:\ProgramData\chocolatey\bin;$env:Path"
          [Environment]::SetEnvironmentVariable("Path", $env:Path, [System.EnvironmentVariableTarget]::Process)

          # Verify Lua installation
          Write-Output "Verifying Lua installation..."
          Write-Output "Current PATH: $env:Path"
          Write-Output "Checking for Lua executables:"
          Get-Command lua* -ErrorAction SilentlyContinue | Format-Table -AutoSize

          lua5.1 -v
          if ($LASTEXITCODE -ne 0) {
              Write-Error "Lua not found in PATH"
              Write-Output "Current PATH: $env:Path"
              exit 1
          }

          # Set up package path for tests
          $env:LUA_PATH = "?.lua;?/init.lua;../lua/?.lua;../lua/?/init.lua"
          Write-Output "LUA_PATH set to: $env:LUA_PATH"

          # Run tests
          Write-Output "Running tests..."
          lua5.1 test/test.lua
          if ($LASTEXITCODE -ne 0) {
              Write-Error "Tests failed"
              exit 1
          }

          Write-Output "Tests completed successfully"
          Write-Output "==========================="

      - name: Run Lua tests (macOS)
        if: inputs.platform == 'macos'
        shell: bash
        run: |
          set -e
          source "${{ inputs.venv_path }}/bin/activate"

          # Install Neovim if not present
          if ! command -v nvim &> /dev/null; then
            echo "Installing Neovim..."
            brew install neovim
            # Verify Homebrew installation
            if [ ! -f "/opt/homebrew/bin/nvim" ]; then
              echo "Error: Neovim not found in Homebrew path after installation"
              echo "Checking Homebrew paths:"
              ls -la /opt/homebrew/bin/
              exit 1
            fi
          fi

          # Verify Neovim is available and show its location
          if ! command -v nvim &> /dev/null; then
            echo "Error: Neovim not found in PATH after installation"
            echo "Current PATH: $PATH"
            echo "Homebrew prefix: $(brew --prefix)"
            echo "Homebrew bin: $(brew --prefix)/bin"
            echo "Checking for nvim in common locations:"
            ls -la /opt/homebrew/bin/nvim 2>/dev/null || echo "Not in /opt/homebrew/bin"
            ls -la /usr/local/bin/nvim 2>/dev/null || echo "Not in /usr/local/bin"
            exit 1
          fi
          echo "Using Neovim from: $(which nvim)"
          echo "Neovim version: $(nvim --version | head -n 1)"

          # Set up Lua environment
          export LUA_PATH="?.lua;?/init.lua;../lua/?.lua;../lua/?/init.lua"
          export LUA_CPATH="?.so;?/init.so;../lua/?.so;../lua/?/init.so"

          # Run the test
          nvim --headless -c "lua require('test.lua.test_print_table')" -c "quit"
          if [ $? -ne 0 ]; then
            echo "Error: Test failed with exit code $?"
            exit 1
          fi

      - name: Check formatting (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            try {
                & "${{ inputs.venv_path }}/Scripts/activate.ps1"
                if ($LASTEXITCODE -ne 0) {
                    throw "Activation script failed with exit code $LASTEXITCODE"
                }
            } catch {
                Write-Error "Failed to activate virtual environment: $_"
                Write-Output "Python version: $(python --version)"
                Write-Output "PATH: $env:Path"
                exit 1
            }

            # Ensure stylua is in PATH
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
            $env:Path = "$env:Path;$env:USERPROFILE\.cargo\bin"

            # Verify stylua is available
            $styluaPath = Get-Command stylua -ErrorAction SilentlyContinue
            if (-not $styluaPath) {
              throw "stylua not found in PATH. Current PATH: $env:Path"
            }
            Write-Output "Using stylua from: $($styluaPath.Source)"

            # Check formatting
            stylua --check lua/
            if ($LASTEXITCODE -ne 0) {
              throw "Format check failed for lua/ directory"
            }
            stylua --check after/plugin/
            if ($LASTEXITCODE -ne 0) {
              throw "Format check failed for after/plugin/ directory"
            }
          } catch {
            Write-Error $_.Exception.Message
            exit 1
          }

      - name: Check formatting (macOS)
        if: inputs.platform == 'macos'
        shell: bash
        run: |
          set -e
          source "${{ inputs.venv_path }}/bin/activate"

          # Ensure Cargo is in PATH
          export PATH="$HOME/.cargo/bin:$PATH"
          echo "Updated PATH: $PATH"

          # Check if stylua is installed, install if not found
          if ! command -v stylua &> /dev/null; then
            echo "Installing stylua via Cargo..."
            cargo install stylua
            if [ $? -ne 0 ]; then
              echo "Error: Failed to install stylua"
              exit 1
            fi
          fi

          # Verify stylua is available
          if ! command -v stylua &> /dev/null; then
            echo "Error: stylua not found in PATH after installation"
            echo "Current PATH: $PATH"
            exit 1
          fi
          echo "Using stylua from: $(which stylua)"
          echo "stylua version: $(stylua --version)"

          # Check formatting
          stylua --check lua/
          if [ $? -ne 0 ]; then
            echo "Error: Format check failed for lua/ directory"
            exit 1
          fi
          stylua --check after/plugin/
          if [ $? -ne 0 ]; then
            echo "Error: Format check failed for after/plugin/ directory"
            exit 1
          fi

      - name: Run sanity tests (Windows)
        if: inputs.install_deps && inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
              & "${{ inputs.venv_path }}/Scripts/activate.ps1"
              if ($LASTEXITCODE -ne 0) {
                  throw "Activation script failed with exit code $LASTEXITCODE"
              }
          } catch {
              Write-Error "Failed to activate virtual environment: $_"
              Write-Output "Python version: $(python --version)"
              Write-Output "PATH: $env:Path"
              exit 1
          }

          # Ensure all tools are in PATH
          $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          $env:Path = "$env:Path;C:\tools\neovim\nvim-win64\bin;$env:USERPROFILE\.cargo\bin"

          # Run tests and capture output
          $testOutput = & bash infra/nvim_sanity_test.sh 2>&1
          $test_exit_code = $LASTEXITCODE

          # Display test results
          Write-Output "Test results:"
          $testOutput

          # Exit with the test exit code
          exit $test_exit_code

      - name: Run sanity tests (macOS)
        if: inputs.install_deps && inputs.platform == 'macos'
        shell: bash
        run: |
          source "${{ inputs.venv_path }}/bin/activate"

          # Run tests and capture output
          test_output=$(bash infra/nvim_sanity_test.sh 2>&1)
          test_exit_code=$?

          # Display test results
          echo "Test results:"
          echo "$test_output"

          # Exit with the test exit code
          exit $test_exit_code

      - name: Install system packages with timeout
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            $ErrorActionPreference = 'Stop'
            Write-Output "Installing system packages..."

            # Check for Visual Studio tools
            Write-Output "Checking for Visual Studio tools..."
            $vsTools = Get-Command cl.exe -ErrorAction SilentlyContinue
            if (-not $vsTools) {
                Write-Output "Visual Studio tools not found, installing..."
                $chocoJob = Start-Job -ScriptBlock {
                    choco install visualstudio2019buildtools -y
                    choco install visualstudio2019-workload-vctools -y
                }

                $timeout = 600  # 10 minutes timeout for VS tools
                $result = Wait-Job $chocoJob -Timeout $timeout
                if ($result -eq $null) {
                    Stop-Job $chocoJob
                    Remove-Job $chocoJob
                    throw "Visual Studio tools installation timed out after $timeout seconds"
                }

                $output = Receive-Job $chocoJob
                Remove-Job $chocoJob

                if ($chocoJob.State -eq 'Failed') {
                    throw "Visual Studio tools installation failed: $output"
                }

                # Verify installation
                $vsTools = Get-Command cl.exe -ErrorAction SilentlyContinue
                if (-not $vsTools) {
                    throw "Visual Studio tools installation completed but cl.exe not found in PATH"
                }
                Write-Output "Visual Studio tools installed successfully"
            } else {
                Write-Output "Visual Studio tools found at: $($vsTools.Source)"
            }

            # Install other packages
            Write-Output "Installing Neovim and LuaRocks..."
            $chocoJob = Start-Job -ScriptBlock {
                choco install neovim -y
                choco install luarocks -y
            }

            $timeout = 300  # 5 minutes timeout
            $result = Wait-Job $chocoJob -Timeout $timeout
            if ($result -eq $null) {
                Stop-Job $chocoJob
                Remove-Job $chocoJob
                throw "Chocolatey installation timed out after $timeout seconds"
            }

            $output = Receive-Job $chocoJob
            Remove-Job $chocoJob

            if ($chocoJob.State -eq 'Failed') {
                throw "Chocolatey installation failed: $output"
            }
          } catch {
            Write-Error $_.Exception.Message
            exit 1
          }

      - name: Run Lua tests (Windows)
        if: inputs.platform == 'windows'
        shell: pwsh
        run: |
          try {
            # Debug virtual environment
            Write-Output "=== Virtual Environment Debug ==="
            Write-Output "VENV_PATH: ${{ inputs.venv_path }}"
            Write-Output "VENV_PATH exists: $(Test-Path '${{ inputs.venv_path }}')"
            if (Test-Path '${{ inputs.venv_path }}') {
              Write-Output "VENV_PATH contents:"
              Get-ChildItem '${{ inputs.venv_path }}' -Recurse
            }
            Write-Output "=============================="

            # Activate virtual environment
            $activateScript = Join-Path '${{ inputs.venv_path }}' 'Scripts\Activate.ps1'
            Write-Output "Activation script path: $activateScript"
            Write-Output "Activation script exists: $(Test-Path $activateScript)"

            if (-not (Test-Path $activateScript)) {
              throw "Activation script not found at: $activateScript"
            }

            # Activate virtual environment
            & $activateScript
            if ($LASTEXITCODE -ne 0) {
              throw "Failed to activate virtual environment"
            }

            # Ensure Neovim is in PATH and verify it
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
            $env:Path = "$env:Path;C:\tools\neovim\nvim-win64\bin"

            # Verify Neovim is available
            $nvimPath = Get-Command nvim -ErrorAction SilentlyContinue
            if (-not $nvimPath) {
              throw "Neovim not found in PATH before running tests. Current PATH: $env:Path"
            }
            Write-Output "Using Neovim from: $($nvimPath.Source)"

            # Set up Lua environment
            $env:LUA_PATH = "?.lua;?/init.lua;../lua/?.lua;../lua/?/init.lua"
            $env:LUA_CPATH = "?.dll;?/init.dll;../lua/?.dll;../lua/?/init.dll"

            # Run the test
            nvim --headless -c "lua require('test.lua.test_print_table')" -c "quit"
            if ($LASTEXITCODE -ne 0) {
              throw "Test failed with exit code $LASTEXITCODE"
            }
          } catch {
            Write-Error $_.Exception.Message
            Write-Error "Stack trace: $($_.ScriptStackTrace)"
            exit 1
          }
